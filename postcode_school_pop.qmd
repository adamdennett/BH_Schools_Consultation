---
title: "Catchment Households and Deprivation, Brighton and Hove"
author: "Adam Dennett"
---

In the map below, every circle represents a postcode in Brighton and Hove, sized according to the estimated number of households with dependent children living in that postcode, and coloured according to the proportion of all children in that postcode aged 0-15, living in income deprived families.

Hover the mouse over each dot to see the postcode and estimated counts of households with dependent children.

The boundaries on the map represent the current (2024/25) school catchment boundaries (blue) and the proposed 2026/27 boundaries (red) taken from the [Catchment Area Postcode List](https://www.brighton-hove.gov.uk/schools-and-learning/apply-school/proposed-admission-arrangements-brighton-hove-schools-2026-2027#tab--catchment-area-postcode-list) published by Brighton and Hove District Council

The graphs below the map

These estimates use postcode level population and household estimates derived from the 2021 Census, obtained from NOMIS - <https://www.nomisweb.co.uk/sources/census_2021_pc>

Details of households with dependent children taken from the 2021 Census - Table TS003 Household Composition - <https://www.nomisweb.co.uk/sources/census_2021_bulk>

Deprivation data is taken from the 2019 Index of Multiple Deprivation - <https://imd-by-geo.opendatacommunities.org> - In this case I have used the [Income Deprivation Affecting Children Index](https://opendatacommunities.org/def/concept/general-concepts/imd/idaci) - IDACI.

Counts of households with dependent children have been estimated using household proportions at postcode level to distribute output area level numbers of households with dependent children proportionally to each postcode in each output area.

```{r echo=FALSE, message=FALSE, warning=FALSE, error=FALSE, include=FALSE, results='hide'}
library(tidyr)
library(dplyr)
library(writexl)
library(tidyverse)
library(here)
library(janitor)
library(sf)
library(usethis)
library(tmap)
library(readxl)
library(r5r)
library(RColorBrewer)
library(accessibility)
library(data.table)
library(ggplot2)
library(interp)
library(h3jsr)
library(h3r)
library(osmextract)
library(stplanr)
library(od)
library(tidytransit)
library(ggrepel)
library(DBI)
library(RPostgreSQL)
library(RPostgres)
library(rpostgis)
```

```{r Connect-to-Database, warning=FALSE, message=FALSE, echo=FALSE}
#connect to a local database to store some data later on
con <- dbConnect(RPostgres::Postgres(), 
                 dbname = 'gisdb2',
                 host = 'localhost',
                 port = 5432,
                 user = 'postgres',
                 password = 'postgres',
                 sslmode = 'disable')

#check connection
#dbListTables(con)

```

```{r echo=FALSE, message=FALSE, warning=FALSE, error=FALSE, include=FALSE}
bn_postcodes <- st_read(con, "bn_postcode_centroids")


ew_oa <- st_read(con, "oa_2021_ew_bfc_v8") %>% 
  st_set_crs(27700)
# Filter the data frame
bn_oa <- ew_oa %>%
  filter(grepl("Brighton and Hove", lsoa21nm))

bh_hh_comp <- read_csv("data/bh_hh_comp.csv")
bh_hh_oa_map <- left_join(bh_hh_comp, bn_oa, by = join_by(oa21 == oa21cd))
bh_hh_oa_map <- left_join(bn_oa, bh_hh_comp, by = join_by(oa21cd == oa21))

optionZ <- st_read("data/optionZ_Mar25.geojson")
option0 <- st_read("data/current_catchments_fix.geojson")

bn_all_deprivation <- read_csv("data/bn_all_deprivation.csv") %>% 
  clean_names()

pcds_p003 <- read_csv("data/pcds_p003.csv") %>% clean_names()
pcd_hh_count <- read_csv("data/pcd_p002.csv") %>% clean_names()
pcd_person_count <- read_csv("data/pcd_p001.csv") %>% clean_names()

bh_pcd_hh_count <- pcd_hh_count %>% 
  filter(grepl("^BN", postcode))

bn_postcodes_pop <- bn_postcodes %>%
  select(c("pcd", "pcd2", "pcds", "oa21", "lsoa21", "geometry")) %>%
  merge(bh_pcd_hh_count, by.x = "pcds", by.y = "postcode")

# Calculate the proportion of households in each postcode
bn_postcodes_pop1 <- bn_postcodes_pop %>%
  group_by(oa21) %>%
  mutate(pcd_oa_hh_prop = count / sum(count)) %>%
  ungroup()

bn_postcodes_pop1 <- bn_postcodes_pop1 %>% 
  merge(bh_hh_comp, by.x = "oa21", by.y = "oa21")

bn_postcodes_pop1 <- bn_postcodes_pop1 %>%
  mutate(pcd_dep_ch_hh_count = pcd_oa_hh_prop * all_dependent_ch_hh) 

bn_postcodes_pop1 <- bn_postcodes_pop1 %>%
  mutate(pcd_dep_ch_hh_count_round = round(pcd_oa_hh_prop * all_dependent_ch_hh)) 

bn_postcodes_pop1 <- merge(
  bn_postcodes_pop1, 
  bn_all_deprivation, 
  by.x = "pcds", 
  by.y = "postcode")

#write_csv(bh_pcd_hh_count, "bn_pcd_hh_count.csv")

```

```{r echo=FALSE, message=FALSE, warning=FALSE, error=FALSE}
tmap_mode("view")
tmap_options(check_and_fix = T)

selection <- bn_postcodes_pop1 %>%
  select(c("pcds", "pcd_dep_ch_hh_count_round", "total_hh", "idaci_decile")) %>%
  rename(
    Postcode = pcds,
    `Households with Dependent Children` = pcd_dep_ch_hh_count_round,
    `Total Households` = total_hh,
    `IDACI Decile` = idaci_decile
  )

# # Filter the data
# filtered_data <- bn_postcodes_pop1 %>%
#   filter(pcd_dep_ch_hh_count_round > 5)
# 
# # Adjust the data to emphasize small values
# tm_shape(optionZ) +
#   tm_polygons(alpha = 0,
#               border.col = "red") +
# tm_shape(option0) +
#   tm_polygons(alpha = 0) +
# tm_shape(selection) +
#   tm_dots(
#     size = "Households with Dependent Children",
#     alpha = 0.5,
#     fill = "IDACI Decile",
#     col = "IDACI Decile",
#     col.alpha = 0.2,
#     lwd = 0,
#     palette = "brewer.rd_yl_bu"
#   ) +
#   tm_layout(
#     frame = FALSE,
#     legend.outside = TRUE
#   )


```

```{r echo=FALSE, message=FALSE, warning=FALSE, error=FALSE}
library(leaflet)

optionZ <- st_transform(optionZ, 4326)
option0 <- st_transform(option0, 4326)
selection <- st_transform(selection, 4326)
bn_postcodes_pop1 <- st_transform(bn_postcodes_pop1, 4326)

leaflet() %>%
  # Add a less intrusive basemap
  addProviderTiles(providers$CartoDB.Positron) %>% # Light, minimalistic basemap
  # Add the `optionZ` polygon layer with a red border
  addPolygons(
    data = optionZ,
    color = "red",
    opacity = 0.5,
    fillOpacity = 0
  ) %>%
  # Add the `option0` polygon layer
  addPolygons(
    data = option0,
    color = NULL,
    opacity = 0.5,
    fillOpacity = 0
  ) %>%
  # Add the `selection` point layer with labels
  addCircleMarkers(
    data = selection,
    radius = ~`Households with Dependent Children` / 2.5,
    color = ~colorFactor(palette = "RdYlBu", domain = selection$`IDACI Decile`)(`IDACI Decile`),
    fillColor = ~colorFactor(palette = "RdYlBu", domain = selection$`IDACI Decile`)(`IDACI Decile`),
    fillOpacity = 0.5,
    opacity = 0.2,
    stroke = FALSE,
    label = ~paste(
      Postcode,
      "Households Dependent Children:", `Households with Dependent Children`,
      "Total Households:", `Total Households`,
      "IDACI Decile:", `IDACI Decile`
    ) # Tooltips for mouseover interactivity
  ) %>%
  # Add a legend for IDACI Decile
  addLegend(
    pal = colorFactor(palette = "RdYlBu", domain = selection$`IDACI Decile`),
    values = selection$`IDACI Decile`,
    title = "IDACI Decile",
    opacity = 1,
    position = "bottomright"
  )


```

```{r echo=FALSE, message=FALSE, warning=FALSE, error=FALSE}
library(sf)          # For spatial data manipulation
library(dplyr)       # For data manipulation
library(ggplot2)     # For plotting

# 1. Perform spatial join
joined_data1 <- st_join(bn_postcodes_pop1, optionZ, join = st_within)

# 2. Aggregate the data
aggregated_data1 <- joined_data1 %>%
  group_by(id, catchment, idaci_decile) %>%
  summarise(total_dep_ch = sum(pcd_dep_ch_hh_count_round, na.rm = TRUE)) %>%
  ungroup()

# Add the required library for palette
library(RColorBrewer)

# 3. Create a faceted bar graph with custom colors
ggplot(aggregated_data1, aes(x = factor(idaci_decile), y = total_dep_ch, fill = idaci_decile)) +
  geom_bar(stat = "identity") +
  scale_fill_gradientn(
    colors = brewer.pal(11, "RdYlBu"),
    limits = c(0, 10),  # Ensure 0 maps to red and 10 maps to blue
    breaks = 0:10,      # Optional: discrete legend ticks for each decile
    name = "IDACI Decile"
  ) +
  facet_wrap(~ catchment, scales = "fixed") +
  labs(
    title = "Count of Households with Dependent Children by IDACI Decile - New Catchments",
    x = "IDACI Decile",
    y = "Count Households with Dependent Children"
  ) +
  theme_minimal() +
  theme(legend.position = "bottom")  # Adjust the legend position


```

```{r echo=FALSE, message=FALSE, warning=FALSE, error=FALSE}
library(sf)          # For spatial data manipulation
library(dplyr)       # For data manipulation
library(ggplot2)     # For plotting

# 1. Perform spatial join
joined_data2 <- st_join(bn_postcodes_pop1, option0, join = st_within)

# 2. Aggregate the data
aggregated_data2 <- joined_data2 %>%
  group_by(id, catchment, idaci_decile) %>%
  summarise(total_dep_ch = sum(pcd_dep_ch_hh_count_round, na.rm = TRUE)) %>%
  ungroup()

# Add the required library for palette
library(RColorBrewer)

# 3. Create a faceted bar graph with custom colors
ggplot(aggregated_data2, aes(x = factor(idaci_decile), y = total_dep_ch, fill = idaci_decile)) +
  geom_bar(stat = "identity") +
  scale_fill_gradientn(
    colors = brewer.pal(11, "RdYlBu"),
    limits = c(0, 10),  # Ensure 0 maps to red and 10 maps to blue
    breaks = 0:10,      # Optional: discrete legend ticks for each decile
    name = "IDACI Decile"
  ) +
  facet_wrap(~ catchment, scales = "fixed") +
  labs(
    title = "Count of Households with Dependent Children by IDACI Decile - Current Catchments",
    x = "IDACI Decile",
    y = "Count Households with Dependent Children"
  ) +
  theme_minimal() +
  theme(legend.position = "bottom")  # Adjust the legend position


```

```{r echo=FALSE, message=FALSE, warning=FALSE, error=FALSE}
library(dplyr)

# Step 1: Drop geometry and create the unique ID column
aggregated_data1 <- aggregated_data1 %>%
  st_set_geometry(NULL) %>%  # Drop geometry
  mutate(unique_id = paste(catchment, idaci_decile, sep = "_"))

aggregated_data2 <- aggregated_data2 %>%
  st_set_geometry(NULL) %>%  # Drop geometry
  mutate(unique_id = paste(catchment, idaci_decile, sep = "_"))

# Step 2: Perform a full join on the unique ID column
aggregated_data_diff <- aggregated_data1 %>%
  full_join(aggregated_data2, by = "unique_id", suffix = c("_1", "_2")) %>%
  mutate(
    total_dep_ch_1 = replace_na(total_dep_ch_1, 0),  # Set missing values to zero
    total_dep_ch_2 = replace_na(total_dep_ch_2, 0),
    total_dep_ch_diff = total_dep_ch_1 - total_dep_ch_2  # Calculate the difference
  ) %>%
  mutate(
    catchment = if_else(!is.na(catchment_1), catchment_1, catchment_2),  # Resolve `catchment`
    idaci_decile = if_else(!is.na(idaci_decile_1), idaci_decile_1, idaci_decile_2)  # Resolve `idaci_decile`
  ) %>%
  select(
    catchment,
    idaci_decile,
    total_dep_ch_diff
  )



```

```{r echo=FALSE, message=FALSE, warning=FALSE, error=FALSE}
# 3. Create a faceted bar graph with custom colors
ggplot(aggregated_data_diff, aes(x = factor(idaci_decile), y = total_dep_ch_diff, fill = idaci_decile)) +
  geom_bar(stat = "identity") +
  scale_fill_gradientn(
    colors = brewer.pal(11, "RdYlBu"),
    limits = c(0, 10),  # Ensure 0 maps to red and 10 maps to blue
    breaks = 0:10,      # Optional: discrete legend ticks for each decile
    name = "IDACI Decile"
  ) +
  facet_wrap(~ catchment, scales = "fixed") +
  labs(
    title = "Change in Households with Dependent Children by IDACI Decile - Current Catchments",
    x = "IDACI Decile",
    y = "Difference in Count Households with Dependent Children"
  ) +
  theme_minimal() +
  theme(legend.position = "bottom")  # Adjust the legend position
```
